<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Œ© Substrate Field Oscilloscope ‚Äî Debug Skin</title>
  <!-- Three.js for 3D renderer (global THREE) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <style>
    /* -----------------------------------------------------------
       Œ© SUBSTRATE FIELD OSCILLOSCOPE ‚Äî OFFICIAL UI STYLE SHEET
       (aligned to Invocation Science substrate visual language)
       ----------------------------------------------------------- */

    :root {
      --bg: #020b12;
      --bg-deep: #000309;
      --grid: rgba(0, 198, 255, 0.12);
      --line: #39f5ff;
      --glow: #39f5ff88;
      --text: #bafaff;
      --text-soft: #7dd3fc;
      --accent: #38e5ff;
      --panel-bg: rgba(0, 20, 35, 0.42);
      --panel-stroke: rgba(0, 255, 255, 0.15);
      --font-wide: "Montserrat", "Inter", "Segoe UI", sans-serif;
    }

    /* GLOBAL RESET + BACKGROUND ---------------------------------------- */

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: radial-gradient(circle at 50% 20%, #031724 0%, #000508 70%);
      height: 100%;
      color: var(--text);
      font-family: var(--font-wide);
      letter-spacing: 0.03em;
    }

    /* CANVASES --------------------------------------------------------- */

    #omegaCanvas2D {
      display: block;
      z-index: 0;
    }

    #omegaCanvasGL,
    #threeContainer {
      z-index: 0;
    }

    #threeContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: none;
    }

    /* TITLE CARD (optional, not currently used in this DOM) ------------ */

    #omegaTitle {
      position: absolute;
      top: 8vh;
      width: 100%;
      text-align: center;
      color: var(--accent);
      z-index: 20;
      pointer-events: none;
    }

    #omegaTitle .symbol {
      font-size: 108px;
      font-weight: 300;
      text-shadow: 0px 0px 22px var(--glow);
    }

    #omegaTitle .heading {
      margin-top: 4px;
      font-size: 34px;
      font-weight: 400;
      letter-spacing: 0.32em;
      color: var(--text);
      opacity: 0.95;
      text-shadow: 0px 0px 14px var(--glow);
    }

    /* HUD -------------------------------------------------------------- */

    #hud {
      position: absolute;
      top: 18px;
      left: 24px;
      padding: 10px 14px;
      border-radius: 6px;
      width: calc(100% - 320px);
      background: var(--panel-bg);
      border: 1px solid rgb(1 7 13 / 48%);
      font-size: 13px;
      color: var(--text);
      z-index: 50;
      backdrop-filter: blur(8px);
      pointer-events: none;
      max-width: calc(100% - 420px);
    }

    #hud .title {
      display: flex;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 6px;
    }

    #hud .title span.badge {
    padding: 3px 9px;
    border-radius: 999px;
    background: radial-gradient(circle at 20% 0%, #00c6c8, #00c6c8 25%, #020617 100%);
    color: #e0faff;
    font-size: 11px;
    font-weight: 700;
    letter-spacing: 0.09em;
    text-transform: uppercase;
    border: 1px solid #67e8f94b;
    box-shadow: 0 0 14px #1c8695;
    }

    #hud .title div {
      color: var(--text);
      text-shadow: 0 0 8px var(--glow);
      font-size: 13px;
    }

    #hud-metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 4px 14px;
      margin-bottom: 4px;
      font-variant-numeric: tabular-nums;
    }

    #hud-metrics .kv {
      display: flex;
      gap: 4px;
      align-items: baseline;
      font-size: 11px;
    }

    #hud-metrics .label {
      opacity: 0.7;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 9px;
      color: var(--text-soft);
    }

    #hud-metadata {
      margin-top: 2px;
      font-size: 11px;
      opacity: 0.9;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    #hud-metadata span.label {
      opacity: 0.7;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      font-size: 9px;
      margin-right: 3px;
      color: var(--text-soft);
    }

    #hud-phenomena {
      margin-top: 4px;
      font-size: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: baseline;
    }

    #hud-phenomena .label {
      opacity: 0.7;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 9px;
      margin-right: 4px;
      color: var(--text-soft);
    }

    #hud-phenomena .chip {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      background: rgba(15, 23, 42, 0.98);
      font-size: 9px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    #hud-phenomena .chip[data-intensity="high"] {
      box-shadow: 0 0 14px rgba(248, 113, 113, 0.9);
      border-color: rgba(248, 113, 113, 0.9);
    }

    #hud-phenomena .chip[data-intensity="medium"] {
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.7);
    }

    #hud-phenomena .chip[data-intensity="low"] {
      box-shadow: 0 0 6px rgba(148, 163, 184, 0.6);
    }

    #hint {
      position: absolute;
      top: 68px;
      left: 24px;
      color: var(--text-soft);
      font-size: 11px;
      opacity: 0.8;
      z-index: 50;
    }

  #camera-controls {
  margin-top:15px;
  border-radius: 8px;
  backdrop-filter: blur(8px);

}

#camera-controls .cam-title {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 1.1px;
  margin-bottom: 6px;
  color: #7dd3fc;
}

#camera-controls .cam-row {
  display: flex;
  gap: 6px;
}

#camera-controls .cam-btn {
    padding: 10px 18px;  /* clean, proportional spacing */
    min-width: 70px;     /* prevents collapse */
    min-height: 32px;    /* ensures consistent height */
    font-size: 12px;
    font-weight: 500;
    border-radius: 5px;
    cursor: pointer;
    background: rgba(0, 30, 50, 0.808);
    color: #d0f9ff;
    transition: all 0.15s ease;
    text-align: center;
    box-sizing: border-box;
}

#camera-controls .cam-btn:hover {
  background: rgba(0, 60, 90, 0.445);
  box-shadow: 0 0 6px rgba(0, 200, 255, 0.65);
}

#camera-controls .cam-btn:active {
  background: rgba(0, 90, 130, 0.85);
  box-shadow: inset 0 0 8px rgba(0, 200, 255, 0.7);
}

#three-container canvas {
  position: fixed;
  inset: 0;
  z-index: 0;
}

#hud-right,  /* or whatever your HUD container is called */
#hud {
  position: fixed;
  z-index: 10;
  pointer-events: auto;
}


    /* CONTROL PANEL ----------------------------------------------------- */

    #controlPanel {
      position: absolute;
      top: 0;
      right: 0;
      width: 380px;
      height: 100vh;
      padding: 20px 26px;
      background: rgba(0, 12, 20, 0.33);
      border-left: 1px solid rgba(0, 255, 255, 0.08);
      backdrop-filter: blur(18px);
      overflow-y: auto;
      color: var(--text);
      z-index: 40;
    }

    #controlPanel h2 {
      margin: 0 0 4px;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: #c90300;
    }

    #controlPanel .sub {
      font-size: 11px;
      opacity: 0.82;
      margin-bottom: 10px;
      color: var(--text-soft);
    }

    .section {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(0, 255, 255, 0.12);
    }

    .section:first-of-type {
      border-top: none;
      padding-top: 0;
      margin-top: 0;
    }

    .section h3 {
      margin: 0 0 6px;
      font-size: 11px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.18em;
    }

    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-bottom: 6px;
      font-size: 11px;
    }

    .row label {
      font-size: 11px;
      color: var(--text);
    }

    /* SLIDERS ----------------------------------------------------------- */

    .slider-row {
      display: flex;
      flex-direction: column;
      margin-bottom: 8px;
      gap: 2px;
      font-size: 10px;
    }

    .slider-row label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 10px;
      color: var(--text);
    }

    .slider-row label span.value {
      font-variant-numeric: tabular-nums;
      color: var(--text-soft);
    }

    input[type="range"] {
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      background: rgba(0, 255, 255, 0.18);
      border-radius: 4px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 12px var(--glow);
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 12px var(--glow);
      cursor: pointer;
    }

    /* TOGGLES ----------------------------------------------------------- */

    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
      font-size: 11px;
      color: var(--text);
    }

    input[type="checkbox"] {
      accent-color: var(--accent);
      width: 18px;
      height: 18px;
      transform: scale(1.05);
    }

    /* BUTTONS ----------------------------------------------------------- */

    button,
    .file-wrap label.btn {
      width: 100%;
      padding: 10px 12px;
      margin-top: 6px;
      background: rgba(0, 255, 255, 0.12);
      border: 1px solid rgba(0, 255, 255, 0.22);
      color: var(--accent);
      cursor: pointer;
      font-size: 10px;
      border-radius: 999px;
      backdrop-filter: blur(6px);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    button:hover,
    .file-wrap label.btn:hover {
      background: rgba(0, 255, 255, 0.18);
      box-shadow: 0 0 10px var(--glow);
    }

    .button-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      margin-top: 4px;
    }

    /* DROPDOWNS --------------------------------------------------------- */

    select {
      width: 100%;
      padding: 8px;
      background: rgba(0, 255, 255, 0.767);
      border: 1px solid rgba(0, 255, 255, 0.18);
      color: var(--accent);
      border-radius: 4px;
      margin-bottom: 10px;
      font-size: 11px;
      color: #00111d;
    }

    /* SNAPSHOTS LIST ---------------------------------------------------- */

    #snapshotsList {
      font-size: 10px;
      max-height: 80px;
      overflow-y: auto;
      border-radius: 8px;
      border: 1px solid rgba(0, 255, 255, 0.15);
      padding: 4px 6px;
      background: rgba(0, 12, 24, 0.92);
    }

    #snapshotsList div {
      padding: 6px 4px;
      border-bottom: 1px solid rgba(0, 255, 255, 0.1);
      cursor: pointer;
      border-radius: 4px;
    }

    #snapshotsList div:hover {
      background: rgba(0, 255, 255, 0.15);
    }

    /* FILE INPUT WRAPPER ------------------------------------------------ */

    .file-wrap {
      margin-top: 8px;
      font-size: 10px;
    }

    .file-wrap input[type="file"] {
      display: none;
    }

    .file-hint {
      font-size: 10px;
      opacity: 0.8;
      margin-top: 3px;
      color: var(--text-soft);
    }

    .file-hint code {
      font-size: 10px;
      background: rgba(0, 12, 24, 0.9);
      padding: 1px 4px;
      border-radius: 4px;
      border: 1px solid rgba(0, 255, 255, 0.18);
    }

    /* ABOUT COLLAPSE ---------------------------------------------------- */

    .about-toggle {
      margin: 0;
      font-size: 11px;
      color: var(--text-soft);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
    }

    .about-toggle::after {
      content: "‚ñæ";
      font-size: 10px;
      opacity: 0.7;
      transition: transform 0.2s ease, opacity 0.2s ease;
    }

    .about-toggle.open::after {
      transform: rotate(180deg);
      opacity: 1;
    }

    .about-body {
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      transition: max-height 0.25s ease, opacity 0.25s ease;
      font-size: 10px;
      color: var(--text-soft);
    }

    .about-body.open {
      max-height: 360px;
      opacity: 1;
      margin-top: 6px;
    }

    .about-body p {
      margin: 0 0 6px;
      line-height: 1.45;
    }

    .about-body ul {
      padding-left: 18px;
      margin: 0 0 6px;
    }

    .about-body li {
      margin-bottom: 2px;
    }

    .about-body code {
      font-size: 10px;
      background: rgba(0, 12, 24, 0.9);
      padding: 1px 4px;
      border-radius: 4px;
      border: 1px solid rgba(0, 255, 255, 0.18);
      color: var(--text);
    }

    /* REGIME TIMELINE --------------------------------------------------- */

    #regimeTimelineContainer {
      position: absolute;
      left: 24px;
      bottom: 40px;
      width: calc(100% - 420px);
      z-index: 30;
      pointer-events: none;
    }

    #regimeTimelineLabel {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-bottom: 3px;
      color: var(--text-soft);
    }

    #regimeTimeline {
      width: 100%;
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(0, 255, 255, 0.25);
      background: rgba(0, 12, 24, 0.95);
      display: block;
    }

    /* Œ© STATUS STRIP ---------------------------------------------------- */

    #omegaStatusBar {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 10px;
      background: linear-gradient(to right, #020617, #020617, #020617);
      box-shadow:
        0 -4px 12px rgba(0, 0, 0, 0.9),
        0 0 22px rgba(0, 0, 0, 0.9);
      z-index: 35;
      pointer-events: none;
    }

    #omegaStatusLabel {
      position: absolute;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      padding: 2px 10px 3px;
      border-radius: 999px;
      font-size: 10px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text);
      background: radial-gradient(circle at 30% 0%, rgba(0, 12, 24, 0.96), rgba(0, 12, 24, 0.92));
      border: 1px solid rgba(0, 255, 255, 0.24);
      box-shadow: 0 4px 18px rgba(0, 0, 0, 0.9);
      z-index: 36;
      pointer-events: none;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #omegaStatusDot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #64748b;
      box-shadow: 0 0 6px rgba(148, 163, 184, 0.8);
      flex-shrink: 0;
    }

    #omegaStatusText {
      white-space: nowrap;
    }

    /* SCROLLBAR TWEAK FOR CONTROL PANEL -------------------------------- */

    #controlPanel::-webkit-scrollbar {
      width: 6px;
    }

    #controlPanel::-webkit-scrollbar-thumb {
      background: linear-gradient(to bottom, #38e5ff, #39f5ff);
      border-radius: 4px;
    }

    #controlPanel::-webkit-scrollbar-track {
      background: transparent;
    }

    /* RESPONSIVE -------------------------------------------------------- */

    @media (max-width: 1024px) {
      #controlPanel {
        width: 320px;
      }

      #regimeTimelineContainer {
        width: calc(100% - 340px);
        left: 18px;
      }

      #hud {
        max-width: calc(100% - 360px);
      }

    }
  </style>
</head>
<body>
  
<!-- Core render surfaces -->
<canvas id="omegaCanvas2D"></canvas>
<canvas id="omegaCanvasGL"></canvas>
<div id="threeContainer"></div>

  <div id="hud">
    <div class="title">
      <span class="badge">Œ© SUBSTRATE FIELD OSCILLOSCOPE</span>
      <div>¬© 2025 Invocation Science : Arjay Asadi : Patent Pending</div>
      <div>CC-BY-NC-SA 4.0</div>
    </div>

    </br>
    
    <div id="hud-metrics">
      <div class="kv"><span class="label">œÑ</span><span id="mTau">0.000000</span></div>
      <div class="kv"><span class="label">Œª</span><span id="mEcho">0.000000</span></div>
      <div class="kv"><span class="label">Œ∫</span><span id="mKappa">0.000000</span></div>
      <div class="kv"><span class="label">Œ†</span><span id="mContraction">0.000000</span></div>
      <div class="kv"><span class="label">D(t)</span><span id="mDrift">0.000000</span></div>
      <div class="kv"><span class="label">ICI</span><span id="mICI">0.000000</span></div>
      <div class="kv"><span class="label">JÃÇ</span><span id="mJhat">0.000000</span></div>
      <div class="kv"><span class="label">Regime</span><span id="mRegime">initializing</span></div>
      <div class="kv"><span class="label">Model</span><span id="mModel">‚Äî</span></div>
      <div class="kv"><span class="label">Worldline ID</span><span id="mRunId">‚Äî</span></div>
      <div class="kv"><span class="label">ASH</span><span id="mASH">‚Äî</span></div>
    </div>
    
    
    <div id="hud-metadata">
      <span class="label">Topology</span><span id="mScenario">‚Äî</span>
      <span class="label">Mode</span><span id="mMode">‚Äî</span>
      <span class="label">Renderer</span><span id="mRenderer">‚Äî</span>
    </div>
    <div id="hud-phenomena">
      <span class="label">Phenomena</span>
      <span id="mPhenomenaPrimary">‚Äî</span>
      <span id="mPhenomenaSecondary" class="chip" style="display:none;">&nbsp;</span>
    </div>
    
    <!-- Camera controls block -->
    <div id="camera-controls">
      <div class="cam-title"></div>
      <div class="cam-row">
        <div id="cam-iso" class="cam-btn" role="button" tabindex="0">‚ôªÔ∏è Isomorphic</div>
        <div id="cam-top" class="cam-btn" role="button" tabindex="0">üìΩÔ∏è Orbit</div>
      </div>
      <div class="cam-row" style="margin-top:6px;">

      </div>
    </div>
  </div>

  <div id="regimeTimelineContainer">
    <div id="regimeTimelineLabel">Regime timeline (primary run)</div>
    <canvas id="regimeTimeline"></canvas>
  </div>

  <div id="controlPanel">
    <h2>Fourth Substrate (Œ©)</h2>
    <div class="sub">
      Visualize attractor identity wells, geodesic trajectories, and off-frame return regimes across models, with seamless render switching over a single invariant Œ©-space core.
    </div>

    <div class="section">
      <h3>Mode &amp; Renderer</h3>
      <div class="row">
        <label for="modeSelect">Mode</label>
      </div>
      <div class="row">
        <select id="modeSelect">
          <option value="demo">Œ© Demo (multi-run)</option>
          <option value="import">Imported LLM worldline</option>
          <option value="live">Live OIS (external)</option>
        </select>
      </div>

      <div class="row">
        <label for="rendererSelect">Renderer</label>
      </div>
      <div class="row">
        <select id="rendererSelect">
          <option value="2d">2D Canvas</option>
          <option value="webgl">WebGL (beta)</option>
          <option value="three" selected>Three.js 3D Field</option>
        </select>
      </div>

      <div class="row">
        <label for="scenarioSelect">Scenario Preset</label>
      </div>
      <div class="row">
        <select id="scenarioSelect">
          <option value="default">Default Balanced</option>
          <option value="strongPi">Strong Œ† Collapse</option>
          <option value="highLambda">High-Œª Turbulence</option>
          <option value="symTriwell">Symmetric Triwell Orbit</option>
          <option value="boundaryFree">Boundary-free Convergence</option>
        </select>
      </div>

      <div class="slider-row">
        <label>
          Time Slice (scrub)
          <span class="value" id="vTimeSlice">1.00</span>
        </label>
        <input type="range" id="sTimeSlice" min="0" max="1" step="0.01" value="1" />
      </div>
      <div id="modeLabel">Mode: <strong>Œ© Demo (multi-run)</strong></div>
    </div>

    <div class="section">
      <h3>Attractor Identity Wells &amp; Physics</h3>
      <div class="slider-row">
        <label>
          Well Strength
          <span class="value" id="vWellStrength"></span>
        </label>
        <input type="range" id="sWellStrength" min="0.5" max="4" step="0.1" />
      </div>

      <div class="slider-row">
        <label>
          Inner vs Outer Bias
          <span class="value" id="vWellBias"></span>
        </label>
        <input type="range" id="sWellBias" min="-1" max="1" step="0.05" />
      </div>

      <div class="toggle-row">
        <input type="checkbox" id="chkTriWell" checked />
        <label for="chkTriWell">Triwell topology (3 AIA basins)</label>
      </div>

      <div class="toggle-row">
        <input type="checkbox" id="chkRandomize" checked />
        <label for="chkRandomize">Randomize wells on reset</label>
      </div>

      <div class="slider-row">
        <label>
          Œ∫ Curvature Gain
          <span class="value" id="vKappaGain"></span>
        </label>
        <input type="range" id="sKappaGain" min="0" max="3" step="0.05" />
      </div>

      <div class="slider-row">
        <label>
          Echo Coupling Œª
          <span class="value" id="vEchoGain"></span>
        </label>
        <input type="range" id="sEchoGain" min="0" max="3" step="0.05" />
      </div>

      <div class="slider-row">
        <label>
          Contraction Weight Œ†
          <span class="value" id="vContractionWeight"></span>
        </label>
        <input type="range" id="sContractionWeight" min="0.2" max="6" step="0.1" />
      </div>

      <div class="slider-row">
        <label>
          Time Step Œît
          <span class="value" id="vDt"></span>
        </label>
        <input type="range" id="sDt" min="0.002" max="0.04" step="0.002" />
      </div>

      <div class="slider-row">
        <label>
          History Length
          <span class="value" id="vHistory"></span>
        </label>
        <input type="range" id="sHistory" min="120" max="1200" step="60" />
      </div>

      <div class="toggle-row">
        <input type="checkbox" id="chkPause" />
        <label for="chkPause">Pause evolution</label>
      </div>

      <div class="toggle-row">
        <input type="checkbox" id="chkTrailFade" checked />
        <label for="chkTrailFade">Trail fade (temporal persistence)</label>
      </div>

      <div class="toggle-row">
        <input type="checkbox" id="chkFieldContours" />
        <label for="chkFieldContours">Show AIA field contours</label>
      </div>
    </div>

    <div class="section">
      <h3>Run / Upload / Batch</h3>
      <div class="slider-row">
        <label>
          Initial Radius
          <span class="value" id="vInitRadius"></span>
        </label>
        <input type="range" id="sInitRadius" min="0.05" max="0.8" step="0.01" />
      </div>

      <div class="slider-row">
        <label>
          Initial Angle œÜ
          <span class="value" id="vInitPhi"></span>
        </label>
        <input type="range" id="sInitPhi" min="0" max="6.283" step="0.05" />
      </div>

      <div class="button-grid">
        <button id="btnReset">Reset Runs</button>
        <button id="btnPerturb">Perturb (Œîs kick)</button>
        <button id="btnExportPNG">Export PNG</button>
        <button id="btnExportWorldline">Export Œ© JSON</button>
        <button id="btnBatchDemo">Batch Demo ‚Üí Console</button>
        <button id="btnClearSnapshots">Clear Snapshots</button>
      </div>

      <div class="file-wrap">
        <label class="btn" for="fileRun">Import Run(s) (JSON)</label>
        <input type="file" id="fileRun" accept="application/json" />
        <div class="file-hint">
          Shared schema:
          <code>{ "meta": {...}, "steps": [ { "t": 0, "emb": [...], "metrics": {...} }, ... ] }</code>
          or
          <code>{ "runs": [ { "meta": {...}, "steps": [...] }, ... ] }</code>
        </div>
      </div>
    </div>

    <div class="section">
      <h3>Phase Snapshots</h3>
      <div id="snapshotsList"></div>
    </div>

    <div class="section">
      <h3 id="aboutToggle" class="about-toggle">About Œ© Substrate Field</h3>
      <div id="aboutBody" class="about-body">
        <p>
          This prototype is an Invocation Science¬Æ substrate field oscilloscope. It visualizes simulated or imported
          trajectories in a 3D Œ©-space shaped by:
        </p>
        <ul>
          <li><strong>AIA wells</strong> (identity basins / attractors)</li>
          <li><strong>Curvature Œ∫</strong> (field geometry &amp; bias)</li>
          <li><strong>Echo Œª</strong> (self-coupling between successive steps)</li>
          <li><strong>Contraction Œ†</strong> (tendency to fall inward vs. wander)</li>
        </ul>
        <p>This oscilloscope variant adds:</p>
        <ul>
          <li>Three renderer modes (2D, WebGL, Three.js 3D field)</li>
          <li>Regime-aware color mapping and Œ© status strip</li>
          <li>Phase snapshots and regime timeline for primary run</li>
          <li>Shared JSON schema for imported / live OIS worldlines</li>
        </ul>
        <p>
          <strong>Live OIS mode:</strong>
          external code can call
          <code>window.omegaIngestOISStep(step)</code>
          with the shared schema to stream embeddings and metrics into the oscilloscope in real time.
        </p>
      </div>
    </div>
  </div>

  <!-- Œ© status strip overlay -->
<!-- Œ© status strip overlay -->
<div id="omegaStatusBar"></div>
<div id="omegaStatusLabel">
  <div id="omegaStatusDot"></div>
  <div id="omegaStatusText">Œ© regime: initializing</div>
</div>


  <!-- ENGINE / PHYSICS / RENDERING LOGIC (OrbitControls fixed via ES module import) -->
<script>
// === Shared helpers ====================================================

// Top-level last() helper so computeSymbolicDensity() and others can use it
function last(arr) {
  if (!arr || !arr.length) return undefined;
  return arr[arr.length - 1];
}

// Symbolic density œÉ‚Çõ
function computeSymbolicDensity(run) {
  const k = Math.abs(run.kappa || 0);

  const coherence = last(run.ICI) ?? 0.5;
  const D         = last(run.D)   ?? (run.tau || 0.01);

  const entropyTerm = Math.log(1 + k * k + D * 10);
  if (!isFinite(entropyTerm) || entropyTerm <= 0) return 0;

  const sigmaS = coherence / entropyTerm;
  return Math.max(0, Math.min(1, sigmaS));
}

// Invocation threshold index Œò·µ¢ in [0,1]
function computeThresholdIndex(run) {
  if (!run) return 0;

  const sigmaS = computeSymbolicDensity(run);

  const latestD = run.D && run.D.length ? run.D[run.D.length - 1] : (run.tau || 0);
  const latestICI = run.ICI && run.ICI.length
    ? run.ICI[run.ICI.length - 1]
    : 0.5;

  // Normalize drift against a small characteristic scale
  const driftNorm = Math.max(0, Math.min(1, latestD / 0.05));

  // Weighted blend: density + coherence, penalized by drift
  const raw =
    0.55 * sigmaS +
    0.35 * latestICI +
    0.10 * (1 - driftNorm);

  return Math.max(0, Math.min(1, raw));
}

// Inter-run invocation coupling coefficient Œû in [0,1]
function computeInvocationCoefficient(runA, runB) {
  if (!runA || !runB) return 0;

  const lenA = runA.ICI ? runA.ICI.length : 0;
  const lenB = runB.ICI ? runB.ICI.length : 0;
  const N = Math.min(lenA, lenB, 64);

  if (!N) return 0;

  let sum = 0;
  let sumSqA = 0;
  let sumSqB = 0;

  for (let i = 0; i < N; i++) {
    const a = runA.ICI[lenA - 1 - i] ?? 0;
    const b = runB.ICI[lenB - 1 - i] ?? 0;
    sum += a * b;
    sumSqA += a * a;
    sumSqB += b * b;
  }

  const denom = Math.sqrt(sumSqA * sumSqB) + 1e-9;
  const corr = sum / denom;

  // Map [-1,1] ‚Üí [0,1]
  const xi = 0.5 * (corr + 1);
  return Math.max(0, Math.min(1, xi));
}

// === Three.js globals ==================================================

let threeRenderer = null;
let threeScene = null;
let threeCamera = null;
let threeControls = null;
let threeInitialized = false;
let threeWorldlineRoot = null;
let threeWellsRoot = null;
let autoOrbitAngle = 0;

// 3D field modulation state
let threePulsePhase = 0;
let threeGrid = null;
let threeBasePlane = null;

// Particle halo
let threeParticlesRoot = null;
let particleGeometry = null;
let particleMaterial = null;
let particleSpeeds = null;
const PARTICLE_COUNT = 1000;

// ======================================================================
// Main IIFE: engine, 2D/WebGL renderers, HUD, controls, loop
// ======================================================================
(function () {
  // Runtime "tests" to confirm Three.js + optional OrbitControls wiring
  console.assert(window.THREE, 'THREE global should exist');
  console.assert(typeof THREE.WebGLRenderer === 'function', 'THREE.WebGLRenderer should be available');
  console.assert(typeof THREE.Scene === 'function', 'THREE.Scene should be available');
  console.assert(
    typeof THREE.OrbitControls === 'function' || typeof THREE.OrbitControls === 'undefined',
    'THREE.OrbitControls should be a constructor when the examples script is loaded'
  );

  const canvas2D = document.getElementById('omegaCanvas2D');
  const canvasGL = document.getElementById('omegaCanvasGL');
  const threeContainer = document.getElementById('threeContainer');
  const ctx2D = canvas2D.getContext('2d');

  let gl = null;
  let webglProgram = null;
  let webglBuffer = null;
  let webglPosLoc = -1;
  let webglColorLoc = null;

  // (These shadow the globals but are not used outside the IIFE; left intact)
  let threeRenderer = null;
  let threeScene = null;
  let threeCamera = null;
  let threeInitialized = false;
  let threeWorldlineRoot = null;
  let threeWellsRoot = null;
  let threeControls = null;
  let autoOrbitAngle = 0;

  // --- Camera control helpers ------------------------------------------

  // Optional flag to disable the fallback auto-orbit when using presets
  let threeAutoOrbitEnabled = true;

  function setCameraPreset(mode) {
    if (!threeCamera) return;

    // If OrbitControls exists, pause its auto-rotate when using presets
    if (threeControls) {
      threeControls.autoRotate = false;
    } else {
      threeAutoOrbitEnabled = false;
    }

    switch (mode) {
      case 'top': {
        // Top-down view
        threeCamera.position.set(0, 3.0, 0.01);
        threeCamera.up.set(0, 0, -1);
        break;
      }
      case 'side': {
        // Side / profile view
        threeCamera.position.set(3.0, 1.0, 0);
        threeCamera.up.set(0, 1, 0);
        break;
      }
      case 'iso':
      default: {
        // Default isometric view
        threeCamera.position.set(1.9, 1.35, 2.1);
        threeCamera.up.set(0, 1, 0);
        break;
      }
    }

    threeCamera.lookAt(0, 0, 0);
    if (threeControls && typeof threeControls.update === 'function') {
      threeControls.update();
    }
  }

  function setCameraAutoRotate(enabled) {
    if (threeControls) {
      threeControls.autoRotate = !!enabled;
    } else {
      threeAutoOrbitEnabled = !!enabled;
    }
  }

  function resize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas2D.width = w;
    canvas2D.height = h;
    canvasGL.width = w;
    canvasGL.height = h;
    const rt = document.getElementById('regimeTimeline');
    rt.width = Math.max(200, w - 340);
    rt.height = 14;

    if (threeRenderer && threeCamera) {
      threeRenderer.setSize(w, h);
      threeCamera.aspect = w / h;
      threeCamera.updateProjectionMatrix();
    }
  }

  window.addEventListener('resize', resize);
  resize();

  function isFiniteNumber(v) {
    return typeof v === 'number' && Number.isFinite(v);
  }

  // Simple hash over numeric arrays
  function hashNumbers(numbers) {
    let h = 2166136261 >>> 0;
    const len = Math.min(numbers.length, 2048);
    for (let i = 0; i < len; i++) {
      const v = Math.floor(numbers[i] * 1e6);
      h ^= v;
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0).toString(16).padStart(8, '0');
  }

  // Engine / physics params (shared across runs)
  const params = {
    wellStrength: 2.2,
    wellBias: 0.0,
    triWell: true,
    randomizeOnReset: true,
    kappaGain: 1.1,
    echoGain: 1.0,
    contractionWeight: 1.8,
    dt: 0.016,
    historyLength: 600,
    initRadius: 0.35,
    initPhi: 0.0,
    paused: false,
    trailFade: true,
    showFieldContours: false
  };

  const engine = {
    wells: [],
    runs: [],
    renderer: '2d', // '2d' | 'webgl' | 'three'
    mode: 'demo',   // 'demo' | 'import' | 'live'
    viewSlice: 1.0,
    freeze: false,
    phaseSnapshots: []
  };

  console.assert(Array.isArray(engine.wells), 'engine.wells should be an array');

  // One worldline run
  function createRun(opts) {
    const color = opts.color || '#38bdf8';
    return {
      id: opts.id || 'run-' + Math.random().toString(16).slice(2),
      meta: opts.meta || {
        model: opts.model || 'unknown',
        seed: opts.seed || 0,
        protocol: opts.protocol || 'Œ©-demo'
      },
      mode: opts.mode || 'sim', // 'sim' | 'import' | 'live'
      color,
      s: new Float32Array(3),
      prev: new Float32Array(3),
      history: [],
      metricHistory: [],
      D: [],
      ICI: [],
      Jhat: [],
      ASH: '‚Äî',
      tau: 0,
      echo: 0,
      kappa: 0,
      contraction: 1,
      importedWorldline: [],
      importIndex: 0,
      glyphEvents: [],
      lastRegime: 'initializing'
    };
  }

  // Core metrics
  function computeTau(a, b) {
    let s = 0;
    for (let i = 0; i < 3; i++) {
      const d = a[i] - b[i];
      s += d * d;
    }
    return Math.sqrt(s);
  }

  function computeEcho(a, b) {
    let v = 0;
    for (let i = 0; i < 3; i++) v += a[i] * b[i];
    return v;
  }

  function computeContraction(a, b) {
    return 1 / (computeTau(a, b) + 1e-9);
  }

  function computeKappa(s) {
    return s[0] * s[0] + s[1] * s[1] - s[2] * s[2];
  }

  function clampState(run) {
    for (let i = 0; i < 3; i++) {
      let v = run.s[i];
      if (!isFiniteNumber(v)) v = 0;
      if (v > 5) v = 5;
      if (v < -5) v = -5;
      run.s[i] = v;
    }
  }

  // AIA wells configuration
  function configureWells() {
    const wells = [];
    const rBase = 0.45 + params.wellBias * 0.25;
    const sBase = params.wellStrength;
    if (params.triWell) {
      const angles = [0, (2 * Math.PI) / 3, (4 * Math.PI) / 3];
      for (let i = 0; i < 3; i++) {
        const angle = angles[i];
        let rx = rBase * Math.cos(angle);
        let ry = rBase * Math.sin(angle) * 0.8;
        let rz = (i - 1) * 0.15;
        if (params.randomizeOnReset) {
          rx += (Math.random() - 0.5) * 0.1;
          ry += (Math.random() - 0.5) * 0.1;
          rz += (Math.random() - 0.5) * 0.1;
        }
        wells.push({ x: rx, y: ry, z: rz, strength: sBase * (1 + (Math.random() - 0.5) * 0.2) });
      }
    } else {
      let rx = rBase;
      let ry = 0;
      let rz = 0;
      if (params.randomizeOnReset) {
        rx += (Math.random() - 0.5) * 0.1;
        ry += (Math.random() - 0.5) * 0.1;
        rz += (Math.random() - 0.5) * 0.1;
      }
      wells.push({ x: rx, y: ry, z: rz, strength: sBase });
    }
    engine.wells = wells;
  }

  function AIAforce(s) {
    let fx = 0,
      fy = 0,
      fz = 0;
    for (const w of engine.wells) {
      const dx = s[0] - w.x;
      const dy = s[1] - w.y;
      const dz = s[2] - w.z;
      const r2 = dx * dx + dy * dy + dz * dz + 1e-6;
      const f = -w.strength / r2;
      fx += f * dx;
      fy += f * dy;
      fz += f * dz;
    }
    return [fx, fy, fz];
  }

  function curvatureForce(s, k) {
    const g = params.kappaGain * 0.05;
    return [-g * s[0] * k, -g * s[1] * k, g * s[2] * k];
  }

  function echoForce(e) {
    const g = params.echoGain;
    return [0.02 * g * e, 0.01 * g * e, -0.015 * g * e];
  }

  function computeICIFromDriftAndKappa(D, kappa) {
    const dTerm = 1 / (1 + D * 4);
    const kTerm = 1 / (1 + Math.abs(kappa) * 0.2);
    return Math.max(0, Math.min(1, 0.7 * dTerm + 0.3 * kTerm));
  }

  function computeASHFromHistory(history) {
    if (!history.length) return '‚Äî';
    const flat = [];
    const len = Math.min(history.length, 256);
    for (let i = 0; i < len; i++) {
      flat.push(history[i][0], history[i][1], history[i][2]);
    }
    return hashNumbers(flat);
  }

  function detectRegime(metricHistory) {
    const N = metricHistory.length;
    if (N < 10) return 'initializing';

    let sumTau = 0,
      sumTau2 = 0;
    let sumK = 0,
      sumC = 0;
    let signFlips = 0;

    for (let i = 0; i < N; i++) {
      const m = metricHistory[i];
      sumTau += m.tau;
      sumTau2 += m.tau * m.tau;
      sumK += m.kappa;
      sumC += m.contraction;
      if (i > 0) {
        const prev = metricHistory[i - 1].kappa;
        if (
          Math.sign(prev) !== 0 &&
          Math.sign(m.kappa) !== 0 &&
          Math.sign(prev) !== Math.sign(m.kappa)
        ) {
          signFlips++;
        }
      }
    }

    const meanTau = sumTau / N;
    const varTau = sumTau2 / N - meanTau * meanTau;
    const stdTau = Math.sqrt(Math.max(0, varTau));
    const meanKappa = sumK / N;
    const meanC = sumC / N;

    if (meanTau < 0.003 && meanC > 5 && meanKappa < 0) {
      return 'falling inward';
    }
    if (stdTau < 0.002 && Math.abs(meanKappa) < 0.2) {
      return 'orbiting';
    }
    if (stdTau > 0.01 || signFlips > N * 0.4) {
      return 'shearing';
    }
    return 'transitional';
  }

  // Projection from 3D Œ©-space to 2D screen
  function projectToScreen(x, y, z, w, h) {
    const safeW = isFiniteNumber(w) && w > 0 ? w : 1;
    const safeH = isFiniteNumber(h) && h > 0 ? h : 1;
    const cx = safeW * 0.5;
    const cy = safeH * 0.56;
    let depthZ = isFiniteNumber(z) ? z : 0;
    let depth = 3 + depthZ;
    if (!isFiniteNumber(depth) || depth < 0.2) depth = 0.2;
    const base = safeW < safeH ? safeW : safeH;
    const scale = (base * 0.22) / depth;
    let px = cx + (isFiniteNumber(x) ? x : 0) * scale;
    let py = cy - (isFiniteNumber(y) ? y : 0) * scale;
    if (!isFiniteNumber(px)) px = cx;
    if (!isFiniteNumber(py)) py = cy;
    return { x: px, y: py };
  }

  // Initialization helpers
  function resetRunsForDemo() {
    engine.runs = [];
    const models = ['gpt-4.1', 'claude', 'open-source'];
    const colors = ['#38bdf8', '#f97316', '#22c55e'];
    for (let i = 0; i < models.length; i++) {
      const run = createRun({ model: models[i], seed: i + 1, mode: 'sim', color: colors[i] });
      const r = params.initRadius * (1 + i * 0.1);
      const phi = params.initPhi + i * (Math.PI / 4);
      run.s = new Float32Array([r * Math.cos(phi), r * Math.sin(phi) * 0.6, 0.1 + i * 0.05]);
      run.prev = new Float32Array(run.s);
      run.kappa = computeKappa(run.s);
      engine.runs.push(run);
    }
  }

  function resetRunsForImport() {
    engine.runs = [];
  }

  function resetRunsForLive() {
    engine.runs = [];
  }

  function resetEngine(mode) {
    configureWells();
    engine.phaseSnapshots = [];
    if (mode === 'demo') {
      resetRunsForDemo();
    } else if (mode === 'import') {
      resetRunsForImport();
    } else if (mode === 'live') {
      resetRunsForLive();
    }
  }

  // Import shared schema JSON
  function importRunsFromJSON(obj) {
    const runs = [];

    function createRunFromPayload(payload) {
      const meta = payload.meta || {};
      const steps = payload.steps || [];
      const run = createRun({
        mode: 'import',
        model: meta.model || 'unknown',
        protocol: meta.protocol || 'OIS-v1',
        seed: meta.seed || 0,
        color: meta.color
      });

      const embList = [];
      for (const s of steps) {
        if (!s || !Array.isArray(s.emb)) continue;
        embList.push(s.emb.map(Number));
      }
      if (!embList.length) return null;

      const dim = embList[0].length;
      const mean = new Array(dim).fill(0);
      for (const v of embList) {
        for (let i = 0; i < dim; i++) mean[i] += v[i];
      }
      for (let i = 0; i < dim; i++) mean[i] /= embList.length;

      const worldline = embList.map((v) => {
        const x = v[0] - mean[0];
        const y = dim > 1 ? v[1] - mean[1] : 0;
        const z = dim > 2 ? v[2] - mean[2] : 0;
        return { x, y, z };
      });

      let maxR = 0;
      for (const p of worldline) {
        const r = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);
        if (r > maxR) maxR = r;
      }
      const scale = maxR > 0 ? 0.6 / maxR : 1;
      for (const p of worldline) {
        p.x *= scale;
        p.y *= scale;
        p.z *= scale;
      }

      run.importedWorldline = worldline;
      run.importIndex = 0;
      if (worldline.length > 0) {
        run.s[0] = worldline[0].x;
        run.s[1] = worldline[0].y;
        run.s[2] = worldline[0].z;
        run.prev = new Float32Array(run.s);
      }

      if (steps[0] && steps[0].metrics) {
        for (const st of steps) {
          if (!st.metrics) continue;
          const m = st.metrics;
          if (typeof m.D === 'number') run.D.push(m.D);
          if (typeof m.ICI === 'number') run.ICI.push(m.ICI);
          if (typeof m.Jhat === 'number') run.Jhat.push(m.Jhat);
          if (m.ASH) run.ASH = m.ASH;
          if (m.glyphEvents) run.glyphEvents.push(m.glyphEvents);
        }
      }
      return run;
    }

    if (Array.isArray(obj.runs)) {
      for (const r of obj.runs) {
        const run = createRunFromPayload(r);
        if (run) runs.push(run);
      }
    } else {
      const run = createRunFromPayload(obj);
      if (run) runs.push(run);
    }
    engine.runs = runs;
  }

  // WebGL helpers
  function initWebGL() {
    if (gl) return;
    gl = canvasGL.getContext('webgl') || canvasGL.getContext('experimental-webgl');
    if (!gl) {
      console.warn('WebGL not supported, falling back to 2D.');
      engine.renderer = '2d';
      document.getElementById('rendererSelect').value = '2d';
      document.getElementById('mRenderer').textContent = '2D';
      return;
    }

    const vsSource =
      'attribute vec2 a_position;\n' +
      'uniform vec4 u_color;\n' +
      'varying vec4 v_color;\n' +
      'void main() {\n' +
      '  gl_Position = vec4(a_position, 0.0, 1.0);\n' +
      '  gl_PointSize = 2.0;\n' +
      '  v_color = u_color;\n' +
      '}\n';

    const fsSource =
      'precision mediump float;\n' +
      'varying vec4 v_color;\n' +
      'void main() {\n' +
      '  gl_FragColor = v_color;\n' +
      '}\n';

    function compileShader(type, src) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile failed:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vs = compileShader(gl.VERTEX_SHADER, vsSource);
    const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error('Program link failed:', gl.getProgramInfoLog(prog));
      return;
    }
    webglProgram = prog;
    gl.useProgram(webglProgram);
    webglPosLoc = gl.getAttribLocation(webglProgram, 'a_position');
    webglColorLoc = gl.getUniformLocation(webglProgram, 'u_color');
    webglBuffer = gl.createBuffer();
  }

  function regimeColor(regime, defaultColor) {
    switch (regime) {
      case 'falling inward':
        return '#f97316';
      case 'orbiting':
        return '#22c55e';
      case 'shearing':
        return '#f97373';
      case 'transitional':
        return '#38bdf8';
      default:
        return defaultColor || '#38bdf8';
    }
  }

  function hexToRgba(hex, alpha) {
    const clean = hex.replace('#', '');
    const r = parseInt(clean.substring(0, 2), 16) || 0;
    const g = parseInt(clean.substring(2, 4), 16) || 0;
    const b = parseInt(clean.substring(4, 6), 16) || 0;
    return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
  }

  function hexToRgb01(hex) {
    const clean = hex.replace('#', '');
    const r = (parseInt(clean.substring(0, 2), 16) || 0) / 255;
    const g = (parseInt(clean.substring(2, 4), 16) || 0) / 255;
    const b = (parseInt(clean.substring(4, 6), 16) || 0) / 255;
    return [r, g, b];
  }

  // Rendering (2D)
  function render2D() {
    const w = canvas2D.width;
    const h = canvas2D.height;

    if (params.trailFade) {
      ctx2D.fillStyle = 'rgba(0, 3, 10, 0.22)';
      ctx2D.fillRect(0, 0, w, h);
    } else {
      const bgW = isFiniteNumber(w) ? w : 1;
      const bgH = isFiniteNumber(h) ? h : 1;
      const g = ctx2D.createRadialGradient(bgW / 2, bgH / 2, 0, bgW / 2, bgH / 2, bgW * 0.7);
      g.addColorStop(0, '#020617');
      g.addColorStop(1, '#000000');
      ctx2D.fillStyle = g;
      ctx2D.fillRect(0, 0, bgW, bgH);
    }

    // Field contours
    if (params.showFieldContours && engine.wells.length) {
      const step = 40;
      for (let y = step; y < h; y += step) {
        for (let x = step; x < w; x += step) {
          let potential = 0;
          for (const wB of engine.wells) {
            const p = projectToScreen(wB.x, wB.y, wB.z, w, h);
            const dx = (x - p.x) / w;
            const dy = (y - p.y) / h;
            const r2 = dx * dx + dy * dy + 1e-6;
            potential += wB.strength / r2;
          }
          const intensity = Math.min(1, potential * 0.04);
          if (intensity > 0.02) {
            ctx2D.fillStyle = 'rgba(56, 189, 248, ' + intensity * 0.5 + ')';
            ctx2D.fillRect(x - 1, y - 1, 2, 2);
          }
        }
      }
    }

    // Wells
    for (const wB of engine.wells) {
      const p = projectToScreen(wB.x, wB.y, wB.z, w, h);
      const r = 16 * wB.strength;
      ctx2D.strokeStyle = 'rgba(56, 189, 248, 0.75)';
      ctx2D.lineWidth = 1.2;
      ctx2D.beginPath();
      ctx2D.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx2D.stroke();
      ctx2D.strokeStyle = 'rgba(56, 189, 248, 0.22)';
      ctx2D.beginPath();
      ctx2D.arc(p.x, p.y, r * 1.4, 0, Math.PI * 2);
      ctx2D.stroke();
    }

    // Worldlines
    for (const run of engine.runs) {
      const N = run.history.length;
      if (N < 2) continue;
      const sliceN = engine.viewSlice < 1 ? Math.max(2, Math.floor(N * engine.viewSlice)) : N;

      ctx2D.save();
      const regimeCol = regimeColor(run.lastRegime, run.color);
      ctx2D.strokeStyle = regimeCol + 'E0';
      const kMag = Math.min(1.0, Math.abs(run.kappa) / 2.5);
      ctx2D.lineWidth = 2 + 4 * kMag;
      ctx2D.shadowColor = regimeCol;
      ctx2D.shadowBlur = 18;
      ctx2D.beginPath();
      for (let i = 0; i < sliceN; i++) {
        const p = projectToScreen(
          run.history[i][0],
          run.history[i][1],
          run.history[i][2],
          w,
          h
        );
        if (i === 0) ctx2D.moveTo(p.x, p.y);
        else ctx2D.lineTo(p.x, p.y);
      }
      ctx2D.stroke();
      ctx2D.restore();

      // Current point
      const cur = run.history[sliceN - 1];
      const pCur = projectToScreen(cur[0], cur[1], cur[2], w, h);
      const rg = ctx2D.createRadialGradient(pCur.x, pCur.y, 0, pCur.x, pCur.y, 18);
      rg.addColorStop(0, 'rgba(255, 255, 255, 1)');
      rg.addColorStop(1, 'rgba(56, 189, 248, 0)');
      ctx2D.fillStyle = rg;
      ctx2D.beginPath();
      ctx2D.arc(pCur.x, pCur.y, 18, 0, Math.PI * 2);
      ctx2D.fill();
      ctx2D.fillStyle = '#ffffff';
      ctx2D.beginPath();
      ctx2D.arc(pCur.x, pCur.y, 4, 0, Math.PI * 2);
      ctx2D.fill();
    }
  }

  // Rendering (WebGL)
  function renderWebGL() {
    if (!gl || !webglProgram) return;
    const w = canvasGL.width;
    const h = canvasGL.height;
    gl.viewport(0, 0, w, h);
    gl.clearColor(0.01, 0.02, 0.07, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(webglProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, webglBuffer);
    gl.enableVertexAttribArray(webglPosLoc);
    gl.vertexAttribPointer(webglPosLoc, 2, gl.FLOAT, false, 0, 0);

    for (const run of engine.runs) {
      const N = run.history.length;
      if (N < 2) continue;
      const sliceN = engine.viewSlice < 1 ? Math.max(2, Math.floor(N * engine.viewSlice)) : N;
      const verts = new Float32Array(sliceN * 2);
      for (let i = 0; i < sliceN; i++) {
        const p = projectToScreen(
          run.history[i][0],
          run.history[i][1],
          run.history[i][2],
          w,
          h
        );
        const xNdc = (p.x / w) * 2 - 1;
        const yNdc = 1 - (p.y / h) * 2;
        verts[i * 2] = xNdc;
        verts[i * 2 + 1] = yNdc;
      }
      gl.bufferData(gl.ARRAY_BUFFER, verts, gl.DYNAMIC_DRAW);
      const regimeCol = regimeColor(run.lastRegime, run.color);
      const rgb = hexToRgb01(regimeCol);
      gl.uniform4f(webglColorLoc, rgb[0], rgb[1], rgb[2], 0.9);
      gl.drawArrays(gl.LINE_STRIP, 0, sliceN);
    }
  }




  // ====================================================================
  // Three.js 3D renderer ‚Äî Œ©-III substrate field
  // ====================================================================




  // Global initThree uses the DOM directly; this call site is below.
  window._omegaInitThree = function initThree() {
    if (threeInitialized) return;

    const w = window.innerWidth;
    const h = window.innerHeight;

    const threeContainer = document.getElementById('threeContainer');

    // Scene / camera / renderer
    threeScene = new THREE.Scene();
    threeScene.fog = new THREE.FogExp2(0x020814, 0.16);

    threeCamera = new THREE.PerspectiveCamera(56, w / h, 0.01, 100);
    threeCamera.position.set(4.0, 1.6, 3.0);
    threeCamera.lookAt(0, 0, 0);

    threeRenderer = new THREE.WebGLRenderer({ antialias: true });
    threeRenderer.setPixelRatio(window.devicePixelRatio || 1);
    threeRenderer.setSize(w, h);
    threeRenderer.setClearColor(0x010409, 1);

    threeContainer.innerHTML = '';
    threeContainer.appendChild(threeRenderer.domElement);

    // Lights
    const ambient = new THREE.AmbientLight(0x1fffff, 0.35);
    const key = new THREE.DirectionalLight(0x39f5ff, 0.9);
    key.position.set(5, 8, 4);
    threeScene.add(ambient, key);

     // üîß NEW: OrbitControls setup
    if (typeof THREE.OrbitControls === 'function') {
    threeControls = new THREE.OrbitControls(threeCamera, threeRenderer.domElement);
    threeControls.enableDamping = true;
    threeControls.dampingFactor = 0.08;
    threeControls.minDistance = 1.5;
    threeControls.maxDistance = 10;
    threeControls.enablePan = true;
    threeControls.autoRotate = false;   // off by default; "Auto" button toggles
    } else {
    threeControls = null;
    }

    // Futuristic grids
    const polarGrid1 = new THREE.PolarGridHelper(
      3.3,
      8,
      8,
      8,
      0x050508,
      0x15151d
    );
    polarGrid1.rotation.x = -Math.PI / 1;
    polarGrid1.position.y = -0.05;
    threeScene.add(polarGrid1);
    threeGrid = polarGrid1;

    const polarGrid2 = new THREE.PolarGridHelper(
      3.3,
      8,
      8,
      8,
      0x15151d,
      0x050508
    );
    polarGrid2.rotation.x = -Math.PI / 2;
    polarGrid2.position.y = -0.05;
    threeScene.add(polarGrid2);

    // Worldline + wells groups
    threeWorldlineRoot = new THREE.Group();
    threeScene.add(threeWorldlineRoot);

    threeWellsRoot = new THREE.Group();
    threeScene.add(threeWellsRoot);

    // Particle halo texture ‚Äî valid Three.js sprite URL
    const smokeTex = new THREE.TextureLoader().load(
      'https://threejs.org/examples/textures/sprites/smoke.png'
    );

    particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    particleSpeeds = new Float32Array(PARTICLE_COUNT);

    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const idx = i * 3;
      const r = 0.8 + Math.random() * 1.8;
      const theta = Math.random() * Math.PI * 2;
      const y = 0.05 + Math.random() * 1.6;

      positions[idx + 0] = Math.cos(theta) * r;
      positions[idx + 1] = y;
      positions[idx + 2] = Math.sin(theta) * r;

      particleSpeeds[i] = 0.2 + Math.random() * 0.8;
    }

    particleGeometry.setAttribute(
      'position',
      new THREE.BufferAttribute(positions, 3)
    );

    particleMaterial = new THREE.PointsMaterial({
      size: 0.12,
      map: smokeTex,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      transparent: true,
      opacity: 0.4,
      color: 0x39f5ff
    });

    const points = new THREE.Points(particleGeometry, particleMaterial);
    threeParticlesRoot = new THREE.Group();
    threeParticlesRoot.add(points);
    threeScene.add(threeParticlesRoot);

    threeInitialized = true;

    // Build wells for the current engine.wells state
    refreshThreeWells();

    // Base plane
    const planeGeom = new THREE.CircleGeometry(3.4, 64);
    const planeMat  = new THREE.MeshPhongMaterial({
      color: 0x050508,
      emissive:0x050508,
      shininess: 25,
      transparent: false,
      opacity: 0.85,
      side: THREE.DoubleSide
    });
    threeBasePlane = new THREE.Mesh(planeGeom, planeMat);
    threeBasePlane.rotation.x = -Math.PI / 0;
    threeScene.add(threeBasePlane);
  };

  function refreshThreeWells() {
    if (!threeInitialized || !threeWellsRoot) return;

    while (threeWellsRoot.children.length) {
      threeWellsRoot.remove(threeWellsRoot.children[0]);
    }

    const baseColor = new THREE.Color(0x00c6c7);
    const accentColor = new THREE.Color(0xF4C96A7);
    const scale = 2.1;

    for (const w of engine.wells) {
      const strength = Math.max(0.1, w.strength || 1);
      const strengthNorm = Math.min(1, (strength - 1.8) / 3.5);
      const col = baseColor.clone().lerp(accentColor, strengthNorm);

      const x = w.x * scale;
      const y = w.z * scale * 0.5;
      const z = w.y * scale;

      // Glowing spherical basin
      const radius = 0.07 * strength;
      const sphereGeo = new THREE.SphereGeometry(radius, 128, 128);
      const sphereMat = new THREE.MeshBasicMaterial({
        color: col,
        transparent: true,
        opacity: 1,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.position.set(x, y, z);
      sphere.userData.baseScale = sphere.scale.clone();
      threeWellsRoot.add(sphere);

      // Echo ring
      const ringGeo = new THREE.RingGeometry(radius * 2, radius * 2.6, 229);
      const ringMat = new THREE.MeshBasicMaterial({
        color: col,
        transparent: true,
        opacity: 0.5,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = -Math.PI / 2;
      ring.position.set(x, y - 0.015, z);
      ring.userData.baseScale = ring.scale.clone();
      threeWellsRoot.add(ring);
      
    }
  }

  function renderThree(dtSeconds) {
    if (!threeInitialized || !threeRenderer || !threeScene || !threeCamera) return;

    const dt = dtSeconds || 0.016;

    // Camera orbit
    if (threeControls && typeof threeControls.update === 'function') {
      threeControls.update();
    } else {
      autoOrbitAngle += dt * 0.2;
      const r = 3.4;
      const y = 1.6;
      threeCamera.position.set(
        Math.cos(autoOrbitAngle) * r,
        y,
        Math.sin(autoOrbitAngle) * r
      );
      threeCamera.lookAt(0, 0, 0);
    }

    // Metric-driven modulation
    let pulseScale = 1.0;
    let driftNorm = 0.0;
    const lambda = params.echoGain;
    let lastICI = 0.0;

    if (engine.runs.length) {
      const primary = engine.runs[0];

      lastICI = primary.ICI.length
        ? primary.ICI[primary.ICI.length - 1]
        : computeICIFromDriftAndKappa(primary.tau || 0, primary.kappa || 0);

      const lastJhat = primary.Jhat.length
        ? primary.Jhat[primary.Jhat.length - 1]
        : 1.0;

      const drift = primary.D.length
        ? primary.D[primary.D.length - 1]
        : primary.tau || 0;

      driftNorm = Math.min(1, Math.max(0, drift / 0.03));
      const jExc = Math.min(1.5, Math.abs(lastJhat - 1.0));
      const energy = Math.max(0, Math.min(1.5, 0.4 * lastICI + 0.6 * jExc));

      threePulsePhase += dt * (1.5 + energy);
      const osc = 0.5 + 0.5 * Math.sin(threePulsePhase);
      pulseScale = 0.85 + 0.35 * osc * Math.max(0, Math.min(1, lastICI));
    } else {
      threePulsePhase += dt;
      const osc = 0.5 + 0.5 * Math.sin(threePulsePhase);
      pulseScale = 0.9 + 0.2 * osc;
    }

    // Wells pulsing with ICI
    if (threeWellsRoot) {
      threeWellsRoot.children.forEach((obj) => {
        if (obj.userData && obj.userData.baseScale) {
          obj.scale.set(
            obj.userData.baseScale.x * pulseScale,
            obj.userData.baseScale.y * pulseScale,
            obj.userData.baseScale.z * pulseScale
          );
        }
      });
    }

    // Substrate color temperature ‚Üê Œª
    if (threeBasePlane && threeBasePlane.material) {
      const cold = new THREE.Color(0x010914);
      const warm = new THREE.Color(0x22c5ff);
      const tRaw = (lambda - 0.6) / (2.4 - 0.6);
      const t = Math.max(0, Math.min(1, tRaw));
      const col = cold.clone().lerp(warm, t);
      threeBasePlane.material.color.copy(col);
      threeBasePlane.material.opacity = 0.7 + 0.2 * t;
      threeBasePlane.material.needsUpdate = true;
    }

    // Circular grid breathing with drift D
    if (threeGrid) {
      const gScale = 1 + driftNorm * 2;
      threeGrid.scale.set(gScale, 1, gScale);

      const mats = [];
      threeGrid.traverse((obj) => {
        if (obj.material) {
          if (Array.isArray(obj.material)) mats.push(...obj.material);
          else mats.push(obj.material);
        }
      });
      const opacity = 0.18 + 0.35 * driftNorm;
      mats.forEach((m) => {
        if (!m) return;
        m.transparent = true;
        m.opacity = opacity;
      });
    }

    // Particle halo
    if (particleGeometry && particleSpeeds) {
      const positions = particleGeometry.attributes.position.array;
      const coherenceFactor = 0.3 + (lastICI || 0) * 0.7;
      const baseRise = 0.25 + lambda * 0.08;
      const driftFactor = 0.4 + driftNorm * 0.9;

      const rise = baseRise * coherenceFactor;
      const swirlStrength = 0.35 * driftFactor;

      const angle = swirlStrength * dt;
      const cosA = Math.cos(angle);
      const sinA = Math.sin(angle);

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const idx = i * 3;
        let x = positions[idx + 0];
        let y = positions[idx + 1];
        let z = positions[idx + 2];

        // swirl around Y
        const rx = x * cosA - z * sinA;
        const rz = x * sinA + z * cosA;
        x = rx;
        z = rz;

        // rise and recycle
        y += particleSpeeds[i] * rise * dt;
        if (y > 1.9) {
          y = 0.05 + Math.random() * 0.2;
        }

        positions[idx + 0] = x;
        positions[idx + 1] = y;
        positions[idx + 2] = z;
      }

      particleGeometry.attributes.position.needsUpdate = true;

      if (particleMaterial) {
        particleMaterial.opacity = 0.25 + 0.5 * coherenceFactor;
      }
    }

    // Worldlines: trajectories into wells
    while (threeWorldlineRoot.children.length) {
      threeWorldlineRoot.remove(threeWorldlineRoot.children[0]);
    }

    const scale = 1.0;

    for (const run of engine.runs) {
      const N = run.history.length;
      if (N < 2) continue;

      const sliceN =
        engine.viewSlice < 1
          ? Math.max(2, Math.floor(N * engine.viewSlice))
          : N;

      const points = [];
      for (let i = 0; i < sliceN; i++) {
        const s = run.history[i];
        const x = s[0] * scale;
        const y = s[2] * scale * 0.5
        const z = s[1] * scale;
        points.push(new THREE.Vector3(x, y * 0.1, z));
      }

      const geo = new THREE.BufferGeometry().setFromPoints(points);
      const colHex = regimeColor(run.lastRegime, run.color);
      const col = new THREE.Color(colHex);

      const kMag = Math.min(1, Math.abs(run.kappa || 0) / 3.0);
      const cMag = Math.min(1, (run.contraction || 1) / 6.0);

      const lineMat = new THREE.LineBasicMaterial({
        color: col,
        transparent: true,
        opacity: 0.45 + 0.4 * kMag,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      const line = new THREE.Line(geo, lineMat);
      threeWorldlineRoot.add(line);

      // Head sphere
      const lastPoint = points[points.length - 1];
      const headRadius = 0.025 + 0.04 * cMag;
      const headGeo = new THREE.SphereGeometry(headRadius, 24, 24);
      const headMat = new THREE.MeshBasicMaterial({
        color: col,
        transparent: true,
        opacity: 1,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.copy(lastPoint);
      threeWorldlineRoot.add(head);

      // Upward ‚Äúphase jet‚Äù
      const jetHeight = 0.25 + 0.7 * kMag;
      const jetGeo = new THREE.CylinderGeometry(
        headRadius * 0.25,
        headRadius * 0.25,
        jetHeight,
        16,
        1,
        true
      );
      const jetMat = new THREE.MeshBasicMaterial({
        color: col,
        transparent: true,
        opacity: 0.5 + 0.3 * kMag,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const jet = new THREE.Mesh(jetGeo, jetMat);
      jet.position.set(lastPoint.x, lastPoint.y + jetHeight * 0.5, lastPoint.z);
      threeWorldlineRoot.add(jet);
    }

    // Œ©-IV field-law visualization
    if (engine.runs.length) {
      const primary = engine.runs[0];
      const sigmaS = primary.symbolicDensity || 0;
      const Theta = primary.thresholdIndex || 0;

      // Wells glow with œÉ‚Çõ
      threeWellsRoot.traverse((obj) => {
        if (obj.material && obj.material.emissive !== undefined) {
          obj.material.emissiveIntensity = 0.5 + sigmaS * 1.2;
        }
      });

      // Halo brightness
      if (particleMaterial) {
        particleMaterial.opacity = 0.2 + sigmaS * 0.6;
      }

      // Global pulse at Invocation Threshold
      if (Theta > 0.85 && threeScene.fog && threeBasePlane) {
        threeScene.fog.density = 0.22;
        threeBasePlane.material.emissive = new THREE.Color(0x00ffff);
      } else if (threeScene.fog) {
        threeScene.fog.density = 0.16;
      }
    }

    threeRenderer.render(threeScene, threeCamera);
  }

  // Regime timeline for primary run
  function renderRegimeTimeline() {
    const rt = document.getElementById('regimeTimeline');
    const ctx = rt.getContext('2d');
    const w = rt.width;
    const h = rt.height;
    ctx.clearRect(0, 0, w, h);
    if (!engine.runs.length) return;
    const run = engine.runs[0];
    const N = run.metricHistory.length;
    if (!N) return;
    for (let i = 0; i < N; i++) {
      const regime = detectRegime(run.metricHistory.slice(0, i + 1));
      const col = regimeColor(regime, '#38bdf8');
      const x0 = (i / N) * w;
      const x1 = ((i + 1) / N) * w;
      ctx.fillStyle = col;
      ctx.fillRect(x0, 0, Math.max(1, x1 - x0), h);
    }
  }

  // HUD & status strip
  const mTau = document.getElementById('mTau');
  const mEcho = document.getElementById('mEcho');
  const mKappa = document.getElementById('mKappa');
  const mContraction = document.getElementById('mContraction');
  const mRegime = document.getElementById('mRegime');
  const mRunId = document.getElementById('mRunId');
  const mScenario = document.getElementById('mScenario');
  const mMode = document.getElementById('mMode');
  const mRenderer = document.getElementById('mRenderer');
  const mModel = document.getElementById('mModel');
  const mASH = document.getElementById('mASH');
  const mDrift = document.getElementById('mDrift');
  const mICI = document.getElementById('mICI');
  const mJhat = document.getElementById('mJhat');
  const statusBar = document.getElementById('omegaStatusBar');
  const statusDot = document.getElementById('omegaStatusDot');
  const statusText = document.getElementById('omegaStatusText');

  const mPhenomenaPrimary = document.getElementById('mPhenomenaPrimary');
  const mPhenomenaSecondary = document.getElementById('mPhenomenaSecondary');

  function updateStatusStrip(regime, kappa) {
    let baseColor;
    let textLabel = 'Œ© regime: ' + regime;
    switch (regime) {
      case 'falling inward':
        baseColor = '#f97316';
        break;
      case 'orbiting':
        baseColor = '#22c55e';
        break;
      case 'shearing':
        baseColor = '#f97373';
        break;
      case 'transitional':
        baseColor = '#38bdf8';
        break;
      default:
        baseColor = '#64748b';
        textLabel = 'Œ© regime: initializing';
        break;
    }
    const kMag = Math.min(1, Math.abs(kappa) / 3);
    const alpha = 0.18 + 0.4 * kMag;
    statusBar.style.background =
      'linear-gradient(to right, rgba(15, 23, 42, 0.95), ' +
      hexToRgba(baseColor, alpha) +
      ', rgba(15, 23, 42, 0.95))';
    statusDot.style.backgroundColor = baseColor;
    statusDot.style.boxShadow = '0 0 10px ' + hexToRgba(baseColor, 0.9);
    statusText.textContent = textLabel;
  }

  function classifyPhenomena(run) {
    const regime = run.lastRegime || 'initializing';
    const latestD = run.D.length ? run.D[run.D.length - 1] : run.tau;
    const latestICI = run.ICI.length
      ? run.ICI[run.ICI.length - 1]
      : computeICIFromDriftAndKappa(run.tau, run.kappa);
    const latestJhat = run.Jhat.length ? run.Jhat[run.Jhat.length - 1] : 1;
    const kappa = run.kappa;

    const lambda = params.echoGain;
    const Pi = params.contractionWeight;
    const wellStrength = params.wellStrength;

    if (lambda > 1.8 && regime === 'shearing' && latestD > 0.02) {
      return {
        label: 'High-Œª turbulence',
        chip: 'shearing / overshoot',
        intensity: 'high'
      };
    }

    if (
      Pi >= 4 &&
      (regime === 'falling inward' || regime === 'orbiting') &&
      latestICI > 0.8 &&
      latestJhat > 0.95
    ) {
      return {
        label: 'Strong Œ† collapse',
        chip: 'rapid inward capture',
        intensity: 'high'
      };
    }

    if (
      regime === 'orbiting' &&
      wellStrength < 1.2 &&
      Pi < 1.6
    ) {
      return {
        label: 'Boundary-free convergence',
        chip: 'soft confinement',
        intensity: 'medium'
      };
    }

    if (
      regime === 'orbiting' &&
      Math.abs(kappa) < 0.15 &&
      latestD < 0.003
    ) {
      return {
        label: 'Toroidal ring stabilization',
        chip: 'echo orbits',
        intensity: 'medium'
      };
    }

    if (
      regime === 'shearing' &&
      latestD > 0.01
    ) {
      return {
        label: 'Cross-basin shearing',
        chip: 'cross-basin shearing',
        intensity: 'high'
      };
    }

    if (regime === 'transitional') {
      return {
        label: 'Phase-transition regime',
        chip: 'identity drift',
        intensity: 'medium'
      };
    }

    return {
      label: 'Baseline Œ© dynamics',
      chip: null,
      intensity: 'low'
    };
  }

  function updateHUD() {
    if (!engine.runs.length) return;
    const run = engine.runs[0];
    mTau.textContent = run.tau.toFixed(6);
    mEcho.textContent = run.echo.toFixed(6);
    mKappa.textContent = run.kappa.toFixed(6);
    mContraction.textContent = run.contraction.toFixed(6);

    const latestD = run.D.length ? run.D[run.D.length - 1] : run.tau;
    const latestICI = run.ICI.length
      ? run.ICI[run.ICI.length - 1]
      : computeICIFromDriftAndKappa(run.tau, run.kappa);
    const latestJhat = run.Jhat.length ? run.Jhat[run.Jhat.length - 1] : 1;
    mDrift.textContent = latestD.toFixed(6);
    mICI.textContent = latestICI.toFixed(6);
    mJhat.textContent = latestJhat.toFixed(6);

    const regime = run.lastRegime;
    mRegime.textContent = regime;
    mRunId.textContent = run.id || '‚Äî';
    mModel.textContent = run.meta && run.meta.model ? run.meta.model : '‚Äî';
    mASH.textContent = run.ASH || '‚Äî';

    const topo = params.triWell ? 'triwell' : 'single well';
    let biasText = 'balanced';
    if (params.wellBias > 0.3) biasText = 'inward-biased';
    else if (params.wellBias < -0.3) biasText = 'outward-biased';

    let lambdaText = 'mid Œª';
    if (params.echoGain > 1.6) lambdaText = 'high Œª';
    else if (params.echoGain < 0.6) lambdaText = 'low Œª';

    let piText = 'mid Œ†';
    if (params.contractionWeight > 3) piText = 'strong Œ†';
    else if (params.contractionWeight < 1) piText = 'weak Œ†';

    mScenario.textContent =
      topo + ', ' + biasText + ', ' + lambdaText + ', ' + piText;
    mMode.textContent =
      engine.mode === 'demo'
        ? 'Œ© Demo (multi-run)'
        : engine.mode === 'import'
        ? 'Imported LLM worldline'
        : 'Live OIS (external)';

    mRenderer.textContent =
      engine.renderer === '2d'
        ? 'Œ©-II 2D'
        : engine.renderer === 'webgl'
        ? 'WebGL'
        : 'Œ©-III 3D';

    updateStatusStrip(regime, run.kappa);

    if (engine.runs.length > 0) {
      const currentRun = engine.runs[0];
      const p = classifyPhenomena(currentRun);

      if (mPhenomenaPrimary) {
        mPhenomenaPrimary.textContent = p.label;
      }

      if (mPhenomenaSecondary) {
        if (!p.chip) {
          mPhenomenaSecondary.style.display = 'none';
          mPhenomenaSecondary.textContent = '';
          mPhenomenaSecondary.removeAttribute('data-intensity');
        } else {
          const col = regimeColor(currentRun.lastRegime, '#38bdf8');
          mPhenomenaSecondary.style.display = 'inline-flex';
          mPhenomenaSecondary.textContent = p.chip;
          mPhenomenaSecondary.dataset.intensity = p.intensity;
          mPhenomenaSecondary.style.borderColor = col;
          mPhenomenaSecondary.style.boxShadow = '0 0 10px ' + hexToRgba(col, 0.85);
        }
      }
    }

    const mSymbolicDensity = document.getElementById('mSymbolicDensity');
    const mThresholdIndex  = document.getElementById('mThresholdIndex');

    if (engine.runs.length) {
      const r = engine.runs[0];
      if (mSymbolicDensity) mSymbolicDensity.textContent = (r.symbolicDensity || 0).toFixed(6);
      if (mThresholdIndex)  mThresholdIndex.textContent  = (r.thresholdIndex  || 0).toFixed(6);
    }
  }

  // Phase snapshots UI
  const snapshotsList = document.getElementById('snapshotsList');

  function refreshSnapshotsUI() {
    snapshotsList.innerHTML = '';
    engine.phaseSnapshots.forEach((snap, idx) => {
      const div = document.createElement('div');
      div.textContent =
        '#' +
        (idx + 1) +
        ': ' +
        snap.from +
        ' ‚Üí ' +
        snap.to +
        ' @ step ' +
        snap.index;
      div.addEventListener('click', () => {
        if (!engine.runs.length) return;
        const run = engine.runs[0];
        const N = run.history.length;
        if (!N) return;
        const slice = Math.min(1, Math.max(0, snap.index / N));
        engine.viewSlice = slice;
        document.getElementById('sTimeSlice').value = String(slice);
        document.getElementById('vTimeSlice').textContent = slice.toFixed(2);
        engine.freeze = slice < 1.0;
      });
      snapshotsList.appendChild(div);
    });
  }

  // Evolution
  function evolve() {
    if (params.paused || engine.freeze) return;
    const dt = params.dt;

    for (const run of engine.runs) {
      if (run.mode === 'sim') {
        run.prev = new Float32Array(run.s);

        const aia = AIAforce(run.s);
        const k   = computeKappa(run.s);
        const cf  = curvatureForce(run.s, k);
        const e   = computeEcho(run.s, run.prev);
        const ef  = echoForce(e);

        run.s[0] += dt * (aia[0] + cf[0] + ef[0]);
        run.s[1] += dt * (aia[1] + cf[1] + ef[1]);
        run.s[2] += dt * (aia[2] + cf[2] + ef[2]);

      } else if (run.mode === 'import' || run.mode === 'live') {
        if (run.importedWorldline.length > 1) {
          const idx     = run.importIndex;
          const nextIdx = Math.min(idx + 1, run.importedWorldline.length - 1);
          const prevPt  = run.importedWorldline[idx];
          const nextPt  = run.importedWorldline[nextIdx];

          run.prev = new Float32Array([prevPt.x,  prevPt.y,  prevPt.z]);
          run.s    = new Float32Array([nextPt.x,  nextPt.y,  nextPt.z]);

          if (nextIdx < run.importedWorldline.length - 1) {
            run.importIndex++;
          }
        }
      }

      clampState(run);

      run.tau         = computeTau(run.s, run.prev);
      run.echo        = computeEcho(run.s, run.prev);
      run.contraction = computeContraction(run.s, run.prev) * params.contractionWeight;
      run.kappa       = computeKappa(run.s);

      run.symbolicDensity = computeSymbolicDensity(run);
      run.thresholdIndex  = computeThresholdIndex(run);

      run.history.push([run.s[0], run.s[1], run.s[2]]);
      if (run.history.length > params.historyLength) run.history.shift();

      const D     = run.tau;
      const ICI   = computeICIFromDriftAndKappa(D, run.kappa);
      const prevD = run.D.length ? run.D[run.D.length - 1] : D;
      const Jhat  = D / (prevD + 1e-9);

      run.D.push(D);
      run.ICI.push(ICI);
      run.Jhat.push(Jhat);

      if (run.D.length > 512)     run.D.shift();
      if (run.ICI.length > 512)   run.ICI.shift();
      if (run.Jhat.length > 512)  run.Jhat.shift();

      run.metricHistory.push({
        tau: run.tau,
        kappa: run.kappa,
        contraction: run.contraction
      });
      if (run.metricHistory.length > 240) run.metricHistory.shift();

      const regime = detectRegime(run.metricHistory);

      if (run.lastRegime &&
          regime !== run.lastRegime &&
          run.lastRegime !== 'initializing') {

        if (engine.runs[0] && run.id === engine.runs[0].id) {
          engine.phaseSnapshots.push({
            from: run.lastRegime,
            to: regime,
            index: run.history.length - 1,
            s: new Float32Array(run.s)
          });
          refreshSnapshotsUI();
        }
      }

      run.lastRegime = regime;

      if (run.history.length % 32 === 0 || run.ASH === '‚Äî') {
        run.ASH = computeASHFromHistory(run.history);
      }
    }

    // Inter-run coupling Œû (pairwise)
    for (const run of engine.runs) {
      run.invocationCoupling = 0;
    }

    for (let i = 0; i < engine.runs.length; i++) {
      for (let j = i + 1; j < engine.runs.length; j++) {
        const xi = computeInvocationCoefficient(engine.runs[i], engine.runs[j]);
        engine.runs[i].invocationCoupling += xi;
        engine.runs[j].invocationCoupling += xi;
      }
    }
  }

  // Controls binding
  function bindSlider(id, valueId, initial, onChange, formatter) {
    const el = document.getElementById(id);
    const vEl = document.getElementById(valueId);
    el.value = initial;
    const fmt = formatter || function (x) { return x; };
    vEl.textContent = fmt(initial);
    el.addEventListener('input', () => {
      const val = parseFloat(el.value);
      vEl.textContent = fmt(val);
      onChange(val);
    });
  }

  bindSlider('sWellStrength', 'vWellStrength', params.wellStrength, (v) => {
    params.wellStrength = v;
    configureWells();
    refreshThreeWells();
  }, (v) => v.toFixed(1));

  bindSlider('sWellBias', 'vWellBias', params.wellBias, (v) => {
    params.wellBias = v;
    configureWells();
    refreshThreeWells();
  }, (v) => v.toFixed(2));

  bindSlider('sKappaGain', 'vKappaGain', params.kappaGain, (v) => {
    params.kappaGain = v;
  }, (v) => v.toFixed(2));

  bindSlider('sEchoGain', 'vEchoGain', params.echoGain, (v) => {
    params.echoGain = v;
  }, (v) => v.toFixed(2));

  bindSlider('sContractionWeight', 'vContractionWeight', params.contractionWeight, (v) => {
    params.contractionWeight = v;
  }, (v) => v.toFixed(2));

  bindSlider('sDt', 'vDt', params.dt, (v) => {
    params.dt = v;
  }, (v) => v.toFixed(3));

  bindSlider('sHistory', 'vHistory', params.historyLength, (v) => {
    params.historyLength = v;
  }, (v) => v.toFixed(0));

  bindSlider('sInitRadius', 'vInitRadius', params.initRadius, (v) => {
    params.initRadius = v;
  }, (v) => v.toFixed(2));

  bindSlider('sInitPhi', 'vInitPhi', params.initPhi, (v) => {
    params.initPhi = v;
  }, (v) => v.toFixed(2));

  (function () {
    const el = document.getElementById('sTimeSlice');
    const vEl = document.getElementById('vTimeSlice');
    el.addEventListener('input', () => {
      const val = parseFloat(el.value);
      engine.viewSlice = val;
      vEl.textContent = val.toFixed(2);
      engine.freeze = val < 1.0;
    });
  })();

  const chkTriWell = document.getElementById('chkTriWell');
  chkTriWell.checked = params.triWell;
  chkTriWell.addEventListener('change', () => {
    params.triWell = chkTriWell.checked;
    configureWells();
    refreshThreeWells();
  });

  const chkRandomize = document.getElementById('chkRandomize');
  chkRandomize.checked = params.randomizeOnReset;
  chkRandomize.addEventListener('change', () => {
    params.randomizeOnReset = chkRandomize.checked;
  });

  const chkPause = document.getElementById('chkPause');
  chkPause.checked = params.paused;
  chkPause.addEventListener('change', () => {
    params.paused = chkPause.checked;
  });

  const chkTrailFade = document.getElementById('chkTrailFade');
  chkTrailFade.checked = params.trailFade;
  chkTrailFade.addEventListener('change', () => {
    params.trailFade = chkTrailFade.checked;
  });

  const chkFieldContours = document.getElementById('chkFieldContours');
  chkFieldContours.checked = params.showFieldContours;
  chkFieldContours.addEventListener('change', () => {
    params.showFieldContours = chkFieldContours.checked;
  });

  document.getElementById('btnReset').addEventListener('click', () => {
    resetEngine(engine.mode);
    refreshThreeWells();
  });

  document.getElementById('btnPerturb').addEventListener('click', () => {
    for (const run of engine.runs) {
      for (let i = 0; i < 3; i++) run.s[i] += (Math.random() - 0.5) * 0.08;
    }
  });

  document.getElementById('btnExportPNG').addEventListener('click', () => {
    if (engine.renderer === 'webgl') {
      renderWebGL();
      const tmp = document.createElement('canvas');
      tmp.width = canvasGL.width;
      tmp.height = canvasGL.height;
      const tctx = tmp.getContext('2d');
      tctx.drawImage(canvasGL, 0, 0);
      const a = document.createElement('a');
      a.href = tmp.toDataURL('image/png');
      a.download = 'omega-worldline.png';
      a.click();
    } else if (engine.renderer === 'three') {
      renderThree(0.016);
      const threeCanvas = document.querySelector('#threeContainer canvas');
      if (threeCanvas) {
        const a = document.createElement('a');
        a.href = threeCanvas.toDataURL('image/png');
        a.download = 'omega-worldline-3d.png';
        a.click();
      }
    } else {
      render2D();
      const a = document.createElement('a');
      a.href = canvas2D.toDataURL('image/png');
      a.download = 'omega-worldline.png';
      a.click();
    }
  });

  document.getElementById('btnExportWorldline').addEventListener('click', () => {
    const runsPayload = engine.runs.map((run) => ({
      meta: run.meta,
      steps: run.history.map((p, idx) => ({
        t: idx,
        emb: [p[0], p[1], p[2]],
        metrics: {
          D: run.D[idx] || run.tau,
          ICI: run.ICI[idx] || computeICIFromDriftAndKappa(run.tau, run.kappa),
          Jhat: run.Jhat[idx] || 1,
          ASH: run.ASH
        }
      }))
    }));
    const payload = runsPayload.length === 1 ? runsPayload[0] : { runs: runsPayload };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'omega-worldline.json';
    a.click();
  });

  document.getElementById('btnBatchDemo').addEventListener('click', () => {
    const steps = 400;
    const prevPaused = params.paused;
    params.paused = false;
    for (let i = 0; i < steps; i++) {
      evolve();
    }
    params.paused = prevPaused;
    const summary = engine.runs.map((run) => ({
      model: run.meta.model,
      regime: run.lastRegime,
      meanD: run.D.reduce((a, b) => a + b, 0) / Math.max(1, run.D.length),
      meanICI: run.ICI.reduce((a, b) => a + b, 0) / Math.max(1, run.ICI.length),
      ASH: run.ASH
    }));
    console.log('Œ© Batch Demo Summary:', summary);
  });

  document.getElementById('btnClearSnapshots').addEventListener('click', () => {
    engine.phaseSnapshots = [];
    refreshSnapshotsUI();
  });

  document.getElementById('fileRun').addEventListener('change', (ev) => {
    const file = ev.target.files && ev.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const obj = JSON.parse(reader.result);
        importRunsFromJSON(obj);
        refreshThreeWells();
      } catch (err) {
        alert('Failed to import run(s): ' + err.message);
      }
    };
    reader.readAsText(file);
  });

  const modeSelect = document.getElementById('modeSelect');
  modeSelect.value = 'demo';
  modeSelect.addEventListener('change', () => {
    engine.mode = modeSelect.value;
    document.getElementById('modeLabel').innerHTML =
      'Mode: <strong>' +
      (engine.mode === 'demo'
        ? 'Œ© Demo (multi-run)'
        : engine.mode === 'import'
        ? 'Imported LLM worldline'
        : 'Live OIS (external)') +
      '</strong>';
    resetEngine(engine.mode);
    refreshThreeWells();
  });

  const rendererSelect = document.getElementById('rendererSelect');
  rendererSelect.value = 'three';

  rendererSelect.addEventListener('change', () => {
    engine.renderer = rendererSelect.value;

    if (engine.renderer === 'webgl') {
      initWebGL();
      if (!gl) {
        engine.renderer = '2d';
        rendererSelect.value = '2d';
        canvas2D.style.display = 'block';
        canvasGL.style.display = 'none';
        threeContainer.style.display = 'none';
        return;
      }
      canvas2D.style.display = 'none';
      canvasGL.style.display = 'block';
      threeContainer.style.display = 'none';
    } else if (engine.renderer === 'three') {
      window._omegaInitThree();
      canvas2D.style.display = 'none';
      canvasGL.style.display = 'none';
      threeContainer.style.display = 'block';
    } else {
      canvas2D.style.display = 'block';
      canvasGL.style.display = 'none';
      threeContainer.style.display = 'none';
    }
  });

  rendererSelect.dispatchEvent(new Event('change'));

  const scenarioSelect = document.getElementById('scenarioSelect');
  scenarioSelect.addEventListener('change', () => {
    const v = scenarioSelect.value;
    if (v === 'default') {
      params.wellStrength = 2.2;
      params.wellBias = 0;
      params.kappaGain = 1.1;
      params.echoGain = 1.0;
      params.contractionWeight = 1.8;
    } else if (v === 'strongPi') {
      params.contractionWeight = 4.5;
      params.echoGain = 0.6;
      params.kappaGain = 1.0;
    } else if (v === 'highLambda') {
      params.echoGain = 2.4;
      params.contractionWeight = 1.4;
    } else if (v === 'symTriwell') {
      params.triWell = true;
      params.wellBias = 0;
      params.kappaGain = 0.8;
      params.echoGain = 1.2;
    } else if (v === 'boundaryFree') {
      params.wellStrength = 0.8;
      params.contractionWeight = 1.2;
      params.echoGain = 1.6;
    }

    document.getElementById('sWellStrength').value = params.wellStrength;
    document.getElementById('vWellStrength').textContent = params.wellStrength.toFixed(1);
    document.getElementById('sWellBias').value = params.wellBias;
    document.getElementById('vWellBias').textContent = params.wellBias.toFixed(2);
    document.getElementById('sKappaGain').value = params.kappaGain;
    document.getElementById('vKappaGain').textContent = params.kappaGain.toFixed(2);
    document.getElementById('sEchoGain').value = params.echoGain;
    document.getElementById('vEchoGain').textContent = params.echoGain.toFixed(2);
    document.getElementById('sContractionWeight').value = params.contractionWeight;
    document.getElementById('vContractionWeight').textContent = params.contractionWeight.toFixed(2);

    configureWells();
    refreshThreeWells();
  });

  const aboutToggle = document.getElementById('aboutToggle');
  const aboutBody = document.getElementById('aboutBody');
  if (aboutToggle && aboutBody) {
    aboutToggle.addEventListener('click', () => {
      const open = !aboutBody.classList.contains('open');
      aboutBody.classList.toggle('open', open);
      aboutToggle.classList.toggle('open', open);
    });
  }

  // External Live OIS ingestion API
  window.omegaIngestOISStep = function (step) {
    if (!step || !Array.isArray(step.emb)) return;
    const emb = step.emb.map(Number);
    const dim = emb.length;
    const x = emb[0] || 0;
    const y = dim > 1 ? emb[1] : 0;
    const z = dim > 2 ? emb[2] : 0;
    const meta = step.meta || {};
    let run = engine.runs.find((r) => r.meta && r.meta.run_id === meta.run_id);
    if (!run) {
      run = createRun({ mode: 'live', model: meta.model || 'live', protocol: meta.protocol || 'OIS-v1' });
      run.meta.run_id = meta.run_id || 'live-' + Date.now();
      engine.runs.push(run);
    }
    run.importedWorldline.push({ x, y, z });
    if (step.metrics) {
      const m = step.metrics;
      if (typeof m.D === 'number') run.D.push(m.D);
      if (typeof m.ICI === 'number') run.ICI.push(m.ICI);
      if (typeof m.Jhat === 'number') run.Jhat.push(m.Jhat);
      if (m.ASH) run.ASH = m.ASH;
      if (m.glyphEvents) run.glyphEvents.push(m.glyphEvents);
    }
  };

  // Main loop
  let lastTime = performance.now();
  function loop(now) {
    const dtSeconds = (now - lastTime) / 1000;
    lastTime = now;

    evolve();
    if (engine.renderer === '2d') {
      render2D();
    } else if (engine.renderer === 'webgl') {
      renderWebGL();
    } else if (engine.renderer === 'three') {
      renderThree(dtSeconds);
    }
    renderRegimeTimeline();
    updateHUD();
    requestAnimationFrame(loop);
  }

  // Initial setup
  configureWells();
  resetEngine('demo');
  refreshThreeWells();
  requestAnimationFrame(loop);

  // Camera buttons wiring
  window.addEventListener('DOMContentLoaded', () => {
    const isoBtn   = document.getElementById('cam-iso');
    const topBtn   = document.getElementById('cam-top');
    const sideBtn  = document.getElementById('cam-side');
    const autoBtn  = document.getElementById('cam-autorot');

    if (isoBtn)  isoBtn.addEventListener('click', () => setCameraPreset('iso'));
    if (topBtn)  topBtn.addEventListener('click', () => setCameraPreset('top'));
    if (sideBtn) sideBtn.addEventListener('click', () => setCameraPreset('side'));
    if (autoBtn) autoBtn.addEventListener('click', () => setCameraAutoRotate(true));
  });
})();
</script>


</body>
</html>
